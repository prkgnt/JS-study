# 원시값과 객체의 비교

## 원시 타입과 객체 타입의 비교

- 원시 타입의 값은 변경 불가능한 값이고, 객체 타입의 값은 변경 가능한 값이다.
- 원시 값을 변수에 할당하면 변수에는 실제 값이 저장되고, 객체를 변수에 할당 하면 참조 값이 저장된다.
- 원시 값을 갖는 변수를 다른 변수에 할당하면 원시 값이 복사되어 저장되고, 객체를 가리키는 변수를 다른 변수에 할당하면 참조 값이 복사된다.

## 원시 값

- 원시 값은 변경 불가능한 값이다.
  - 원시 '값' 자체를 변경 불가능 하다는 것이지 변수에 저장된 값은 언제든 재할당을 통해 변경할 수 있다.
  - 원시 값은 어떤 일이 있어도 불변하기에 데이터의 신뢰성을 보장한다.
- 변수 값을 변경하기 위해 원시 값을 재할당하면 새로운 메모리 공간을 확보하고 재할당 한 값을 저장한 뒤 변수가 참조하던 메모리 주소를 새 주소로 변경한다. 이러한 특성을 **불변성**이라고 한다.
- #### 문자열
- 문자열은 원시 값이며 유사 배열 객체이다.
  ```js
  var str = "hello";
  str = "world"; // world 값을 가진 메모리 주소를 가리키도록 변경
  ```
  ```js
  var str = "hello";
  console.log(str[0]); // h -> 배열과 유사하게 인덱스로 접근 가능.
  str[0] = "H"; // -> 원시값이므로 변경 불가
  console.log(str); // 'hello'
  ```

## 객체

- 객체는 변경 가능한 값이다.
- 원시 값을 할당한 변수는 원시 값 자체를 가리키지만 객체를 할당한 변수는 객체를 가리키는 메모리의 주소를 가리킨다.
  ```js
  var person = {
    name: "Lee",
  };
  // person에 저장되어 있는 참조 값으로 실제 객체({name: 'Lee'})에 접근.
  console.log(person); // {name: 'Lee'}
  ```
- 객체 값은 메모리에 저장된 객체를 직접 수정할 수 있다. 이때 원시 값처럼 재할당을 하지 않기 때문에 객체를 할당한 변수의 참조 값은 변경되지 않는다.
- **객체를 변경할 때마다 원시 값처럼 새롭게 생성한다면 신뢰성이 확보되겠지만 메모리의 효율적 소비가 어렵고 성능이 나빠진다. 따라서 메모리의 효율성과 성능을 위해 어느 정도의 구조적인 단점을 감안한 설계이다.**

## 얕은 복사와 깊은 복사

- 얕은 복사와 깊은 복사로 생성된 객체는 원본과는 다른 객체이다. 즉 참조하는 메모리 주소가 다르다.
- 얕은 복사는 객체 안의 객체의 경우 참조 값을 복사하고, 깊은 복사는 객체 안에 객체까지 새로운 참조 값에 복사해낸다.

```js
const o1 = { x: 1 }; // 객체와 그냥 값
const c2 = { ...o1 }; // 얕은 복사
console.log(o1 === c2); // false
console.log(o1.x === c2.x); // 이건 값과 값을 비교하므로 당연히 true

const o = { x: { y: 1 } }; // 객체 안 객체
const c1 = { ...o }; // 얕은 복사
console.log(c1 === o); // false
// 값이 아닌 객체 x를 비교하는 것이기에 x가 참조하는 메모리 주소로 비교하게 됨.
// 하지만 얕은 복사이기 때문에 x가 참조하는 메모리 주소는 동일
console.log(c1.x === o.x); // true
```
